# 前后端对接指南 - 给前端开发人员

## 📋 概述

本文档为前端开发人员提供与Echo AI后端服务对接的详细指南。包含权限控制、认证流程、API接口使用和错误处理等关键信息。请结合[前端开发文档](前端开发文档.md)一起使用。

**重要说明**: 
- 前端已实现语音转文字和语音播报功能，后端专注于文本的AI处理和工具调用

- 🌐 **访问方式**: 前端通过HTTPS访问公网域名，服务器负责SSL终止和请求转发

## 🚀 后端服务信息

### 服务地址

- **API基础路径**: `http://localhost:3000/api/v1` (本地开发环境)
- **API文档**: `http://localhost:3000/docs` (Swagger UI)
- **健康检查**: `http://localhost:3000/health`

### 认证方式
使用 JWT (JSON Web Token) 进行身份认证。

### 用户角色权限
- **user**: 普通用户，可以使用意图解析、工具执行等基础功能
- **developer**: 开发者用户，可以管理自己的工具，访问开发者Portal
- **admin**: 管理员用户，可以管理MCP服务器状态，访问所有管理功能



### 服务状态确认
```bash
# 检查后端服务是否运行
curl http://localhost:3000/health
# 期望响应: {"status":"ok","timestamp":1752568483.0425155}

# 检查API文档是否可访问
curl -I http://localhost:3000/docs
# 期望响应: HTTP/1.1 200 OK
```

## 🔐 认证流程

### 1. 获取访问令牌

**⚠️ 重要**: 登录接口使用 `application/x-www-form-urlencoded` 格式，**不是JSON**

```javascript
// ✅ 正确的登录实现
async function login(username, password) {
  const formData = new URLSearchParams();
  formData.append('username', username);
  formData.append('password', password);
  
  const response = await fetch('http://localhost:3000/api/v1/auth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: formData
  });
  
  if (response.ok) {
    const data = await response.json();
    // 保存token到localStorage或state管理中
    localStorage.setItem('accessToken', data.access_token);
    return data;
  } else {
    throw new Error('登录失败');
  }
}
```

### 2. 使用访问令牌

```javascript
// 在后续API调用中携带token
async function apiCall(endpoint, options = {}) {
  const token = localStorage.getItem('accessToken');
  
  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...options.headers
    }
  };
  
  return fetch(`http://localhost:3000/api/v1${endpoint}`, {
    ...defaultOptions,
    ...options
  });
}
```

## 🔒 权限控制机制

### 用户角色与权限

后端采用基于角色的访问控制(RBAC)，共有三种用户角色：

| 角色 | 权限范围 | 可访问接口 |
|------|----------|------------|
| **user** (普通用户) | 基础功能 | `/api/v1/interpret`、`/api/v1/execute`、`/api/v1/tools` |
| **developer** (开发者) | 基础功能 + 开发者控制台 | 普通用户权限 + `/api/v1/dev/*` |
| **admin** (管理员) | 所有权限 | 所有接口访问权限 |

### 接口权限要求

| 接口路径 | 认证要求 | 角色要求 | 说明 |
|----------|----------|----------|------|
| `POST /api/v1/auth/token` | ❌ 无需认证 | - | 公开登录接口 |
| `POST /api/v1/auth/register` | ❌ 无需认证 | - | 公开注册接口 |
| `GET /health` | ❌ 无需认证 | - | 健康检查接口 |
| `GET /api/v1/auth/me` | ✅ 需要Token | user+ | 获取当前用户信息 |
| `POST /api/v1/interpret` | ✅ 需要Token | user+ | 意图解析 |
| `POST /api/v1/execute` | ✅ 需要Token | user+ | 工具执行 |
| `GET /api/v1/tools` | ✅ 需要Token | user+ | 获取工具列表 |
| `GET /api/v1/dev/tools` | ✅ 需要Token | developer+ | 获取开发者工具列表 |
| `POST /api/v1/dev/tools` | ✅ 需要Token | developer+ | 创建新工具 |
| `PUT /api/v1/dev/tools/{id}` | ✅ 需要Token | developer+ | 更新工具 |
| `DELETE /api/v1/dev/tools/{id}` | ✅ 需要Token | developer+ | 删除工具 |
| `POST /api/v1/dev/tools/{id}/test` | ✅ 需要Token | developer+ | 测试工具 |
| `GET /api/v1/dev/apps` | ✅ 需要Token | developer+ | 获取应用列表 |
| `POST /api/v1/dev/apps` | ✅ 需要Token | developer+ | 创建新应用 |
| `PUT /api/v1/dev/apps/{id}` | ✅ 需要Token | developer+ | 更新应用 |
| `DELETE /api/v1/dev/apps/{id}` | ✅ 需要Token | developer+ | 删除应用 |
| `POST /api/v1/dev/apps/{id}/publish` | ✅ 需要Token | developer+ | 发布应用 |
| `GET /api/v1/mcp/status` | ✅ 需要Token | developer+ | MCP服务器状态 |

### 权限验证流程

```javascript
// 1. 用户登录后获取包含角色信息的Token
const loginResponse = await login('testuser_5090', '8lpcUY2BOt');
// loginResponse.role = "user"

// 2. 后端在每个受保护接口中验证：
//    - Token是否有效
//    - 用户角色是否满足接口要求
//    - 例如：访问/api/v1/dev/tools需要developer或admin角色

// 3. 权限不足时返回403 Forbidden
```

## 🧪 测试账号

后端已预置测试账号，可直接使用：

| 角色 | 用户名 | 密码 | 访问权限 |
|------|--------|------|----------|
| 普通用户 | `testuser_5090` | `8lpcUY2BOt` | 基础AI功能 |
| 开发者 | `devuser_5090` | `mryuWTGdMk` | 基础功能 + 开发者控制台 |
| 管理员 | `adminuser_5090` | `SAKMRtxCjT` | 所有功能 |

## 🔌 核心API接口

### 1. 意图解析接口

```javascript
// POST /api/v1/interpret
async function interpretIntent(query, sessionId = null, userId = 13) {
  const response = await apiCall('/interpret', {
    method: 'POST',
    body: JSON.stringify({
      query: query,
      sessionId: sessionId || generateUUID(),
      userId: userId
    })
  });
  
  return response.json();
  // 响应格式:
  // {
  //   "sessionId": "uuid-string",
  //   "type": "tool_call" | "direct_response",
  //   "content": "回复内容或确认文本",
  //   "toolCalls": [{
  //     "toolId": "tool_name",
  //     "parameters": { /* 工具参数 */ }
  //   }]
  // }
}

// 用户确认执行接口
// POST /api/v1/confirm
async function confirmExecution(sessionId, confirmed) {
  const response = await apiCall('/confirm', {
    method: 'POST',
    body: JSON.stringify({
      sessionId: sessionId,
      confirmed: confirmed  // true表示确认执行，false表示取消
    })
  });
  
  return response.json();
  // 响应格式:
  // {
  //   "sessionId": "uuid-string",
  //   "success": true,
  //   "content": "执行结果内容",
  //   "error": null
  // }
}
```

### 2. 工具执行接口

```javascript
// POST /api/v1/execute
async function executeTask(sessionId, toolId, params, userId = 13) {
  const response = await apiCall('/execute', {
    method: 'POST',
    body: JSON.stringify({
      sessionId: sessionId,
      userId: userId,
      toolId: toolId,
      params: params
    })
  });
  
  return response.json();
  // 响应格式:
  // {
  //   "result": { /* 工具执行结果 */ },
  //   "tts": "翻译完成，结果是：你好",  // 适合语音播报的文本
  //   "sessionId": "uuid-string"
  // }
}
```

### 3. 获取可用工具

```javascript
// GET /api/v1/tools
async function getTools() {
  const response = await apiCall('/tools');
  return response.json();
  // 响应格式:
  // {
  //   "tools": [
  //     {
  //       "tool_id": "translate_text",
  //       "name": "文本翻译",
  //       "description": "支持多语言互译",
  //       "type": "http",
  //       "endpoint": { /* 配置信息 */ }
  //     }
  //   ]
  // }
}
```

### 4. 开发者Portal接口 (需要developer/admin权限)

```javascript
// 工具管理接口
async function getDeveloperTools() {
  const response = await apiCall('/dev/tools');
  return response.json();
}

async function createTool(toolData) {
  const response = await apiCall('/dev/tools', {
    method: 'POST',
    body: JSON.stringify(toolData)
  });
  return response.json();
}

async function updateTool(toolId, toolData) {
  const response = await apiCall(`/dev/tools/${toolId}`, {
    method: 'PUT',
    body: JSON.stringify(toolData)
  });
  return response.json();
}

async function deleteTool(toolId) {
  const response = await apiCall(`/dev/tools/${toolId}`, {
    method: 'DELETE'
  });
  return response.json();
}

async function testTool(toolId, testParams) {
  const response = await apiCall(`/dev/tools/${toolId}/test`, {
    method: 'POST',
    body: JSON.stringify(testParams)
  });
  return response.json();
}

// 应用管理接口
async function getDeveloperApps() {
  const response = await apiCall('/dev/apps');
  return response.json();
}

async function createApp(appData) {
  const response = await apiCall('/dev/apps', {
    method: 'POST',
    body: JSON.stringify(appData)
  });
  return response.json();
}

async function updateApp(appId, appData) {
  const response = await apiCall(`/dev/apps/${appId}`, {
    method: 'PUT',
    body: JSON.stringify(appData)
  });
  return response.json();
}

async function publishApp(appId) {
  const response = await apiCall(`/dev/apps/${appId}/publish`, {
    method: 'POST'
  });
  return response.json();
}

// MCP服务器状态监控
async function getMCPStatus() {
  const response = await apiCall('/mcp/status');
  return response.json();
}
```

## ⚙️ 环境配置

### 前端 `.env` 配置

```bash
# 在前端项目根目录创建 .env 文件
REACT_APP_API_BASE_URL=http://localhost:3000
REACT_APP_API_PREFIX=/api/v1


```

### API客户端封装建议

```javascript
// services/apiClient.js
class ApiClient {
  constructor() {
    this.baseURL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3000';
    this.apiPrefix = process.env.REACT_APP_API_PREFIX || '/api/v1';
  }
  
  // 登录
  async login(username, password) {
    const formData = new URLSearchParams();
    formData.append('username', username);
    formData.append('password', password);
    
    const response = await fetch(`${this.baseURL}${this.apiPrefix}/auth/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    });
    
    if (!response.ok) throw new Error('Login failed');
    return response.json();
  }
  
  // 通用API调用
  async request(endpoint, options = {}) {
    const token = localStorage.getItem('accessToken');
    const url = `${this.baseURL}${this.apiPrefix}${endpoint}`;
    
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...(token && { 'Authorization': `Bearer ${token}` }),
        ...options.headers
      },
      ...options
    };
    
    const response = await fetch(url, config);
    
         if (response.status === 401) {
       // Token过期或无效，清除本地token
       localStorage.removeItem('accessToken');
       throw new Error('Unauthorized - Token expired or invalid');
     }
     
     if (response.status === 403) {
       // 权限不足
       throw new Error('Forbidden - Insufficient permissions');
     }
     
     if (!response.ok) {
       const errorData = await response.json().catch(() => ({}));
       throw new Error(`API Error: ${response.status} - ${errorData.detail || 'Unknown error'}`);
     }
    
    return response.json();
  }
  
  // 意图解析
  async interpret(text, sessionId = null, userId = 13) {
    return this.request('/interpret', {
      method: 'POST',
      body: JSON.stringify({ sessionId, userId, text })
    });
  }
  
  // 工具执行
  async execute(sessionId, toolId, params, userId = 13) {
    return this.request('/execute', {
      method: 'POST',
      body: JSON.stringify({ sessionId, userId, toolId, params })
    });
  }
  
  // 获取工具列表
  async getTools() {
    return this.request('/tools');
  }
}

export default new ApiClient();
```

## 🔄 完整的AI交互流程

```javascript
// 完整的AI交互示例（语音转文字由前端处理）
async function handleUserTextInput(userText) {
  try {
    // 1. 解析用户意图
    const interpretation = await apiClient.interpret(userText);
    console.log('意图解析结果:', interpretation);
    
    // 2. 显示确认文本给用户
    const userConfirmed = await showConfirmation(interpretation.confirmText);
    
    if (userConfirmed) {
      // 3. 执行任务
      const result = await apiClient.execute(
        interpretation.sessionId,
        interpretation.intent,
        interpretation.params
      );
      
      // 4. 返回执行结果和语音播报文本
      // result.tts 是适合语音播报的文本，由前端的语音功能处理
      return {
        success: true,
        result: result.result,
        speechText: result.tts  // 传给前端语音播报功能
      };
    }
  } catch (error) {
    console.error('AI交互失败:', error);
    return {
      success: false,
      error: error.message,
      speechText: '抱歉，处理您的请求时出现了问题'
    };
  }
}
```

## 🚨 常见问题与解决方案

### 1. CORS 错误



**⚠️ 前后端分离部署注意事项**:
- 当前配置已包含 `"*"` 通配符，应该允许所有域名访问
- 如果仍有CORS问题，可能需要在后端.env中明确添加前端服务器地址
- 前端服务器地址格式示例：`http://your-frontend-server:port`

`
**测试CORS配置**:
```bash
# 从前端服务器测试后端连接
curl -H "Origin: http://your-frontend-server:3000" \
     -H "Access-Control-Request-Method: POST" \
     -H "Access-Control-Request-Headers: X-Requested-With" \
     -X OPTIONS \
     https://rqoufedpoguc.sealosgzg.site/api/v1/auth/token
```

### 2. 认证与权限错误
**401 Unauthorized**:
- 确认使用form-data格式而非JSON登录
- 检查用户名和密码是否正确
- 确认token是否正确携带在Authorization头中
- Token可能已过期，需要重新登录

**403 Forbidden**:
- 用户角色权限不足
- 例如：普通user尝试访问`/api/v1/dev/tools`需要developer权限
- 检查当前用户角色是否满足接口要求

### 3. 错误处理最佳实践
```javascript
// 完善的错误处理
async function safeApiCall(apiFunction) {
  try {
    return await apiFunction();
  } catch (error) {
    if (error.message.includes('401')) {
      // Token过期，重新登录
      localStorage.removeItem('accessToken');
      window.location.href = '/login';
    } else if (error.message.includes('403')) {
      // 权限不足，提示用户
      alert('权限不足，请联系管理员或使用具有相应权限的账号');
    } else {
      console.error('API调用失败:', error);
      throw error;
    }
  }
}

// 角色权限检查
function checkPermission(userRole, requiredRole) {
  const roleHierarchy = { 'user': 1, 'developer': 2, 'admin': 3 };
  return roleHierarchy[userRole] >= roleHierarchy[requiredRole];
}
```

### 4. 开发调试
```javascript
// 开发环境下启用详细日志
if (process.env.NODE_ENV === 'development') {
  // 拦截所有fetch请求进行日志记录
  const originalFetch = window.fetch;
  window.fetch = function(...args) {
    console.log('API Request:', args);
    return originalFetch.apply(this, args)
      .then(response => {
        console.log('API Response:', response);
        return response;
      });
  };
}
```

## 📱 前端语音功能对接说明

后端提供的 `result.tts` 字段是专门为前端语音播报功能准备的优化文本：

```javascript
// 后端返回的execute结果中包含tts字段
const result = await apiClient.execute(sessionId, toolId, params);
// result.tts 包含适合语音播报的简洁文本

// 将tts文本传递给前端已实现的语音播报功能
// 具体调用方式请参考前端开发文档中的语音模块
```

**重要说明**：
- 🎤 **语音输入**: 由前端Web Speech API处理，转换为文本后发送给后端
- 🔊 **语音输出**: 后端提供优化的`tts`文本，由前端语音合成功能播报
- 🤖 **AI处理**: 后端专注于文本的意图识别、工具调用和结果处理

## 🔧 开发者工具

### 快速测试API和权限
```bash
# 1. 测试普通用户登录
curl -X POST "http://localhost:3000/api/v1/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=testuser_5090&password=8lpcUY2BOt"

# 2. 使用返回的token测试基础接口（应该成功）
curl -X GET "http://localhost:3000/api/v1/tools" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# 3. 测试开发者接口（普通用户应该返回403）
curl -X GET "http://localhost:3000/api/v1/dev/tools" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# 4. 测试开发者用户登录
curl -X POST "http://localhost:3000/api/v1/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=devuser_5090&password=mryuWTGdMk"

# 5. 开发者token测试开发者接口（应该成功）
curl -X GET "http://localhost:3000/api/v1/dev/tools" \
  -H "Authorization: Bearer DEV_TOKEN_HERE"
```

### 浏览器开发者工具
1. 打开Network选项卡监控API请求
2. 检查Request Headers中是否正确携带Authorization
3. 查看Response确认数据格式

## 📞 支持与反馈

- **API文档**: http://localhost:3000/docs
- **后端日志**: 检查 `backend/logs/api.log`

- **问题反馈**: 请提供具体的错误信息和请求/响应日志
- **架构说明**: 服务器负责SSL终止和端口映射，后端服务专注于业务逻辑处理

---

> 文档更新时间: 2025-07-15  
> 适用后端版本: v0.1.0  
> 文档负责人: 后端团队